# 大带（Large Band）遍历形状详解

## 概述

大带处理采用**窗口式遍历（Window-based Traversal）**，根据矩阵稀疏模式自适应选择最佳窗口形状。

## 窗口形状定义

### 配置参数

```python:61-64:BSGCN_Metis_Order/config.py
LARGE_BAND_PROCESSING = {
    'WINDOW_SHAPES': [(8, 1), (4, 2), (2, 4), (1, 8)],
    'PROFILING_ROWS': 32,
}
```

**窗口形状 `(alpha, beta)`**：
- **alpha**: 窗口高度（行数）
- **beta**: 窗口宽度（列数，实际指并行度）

## 遍历模式

### 代码实现

```python:229-268:BSGCN_Metis_Order/simulator.py
# 窗口式遍历
for i in range(start_row, end_row, alpha):  # ← 每次跳跃 alpha 行
    current_window_start_row = i
    current_window_end_row = min(i + alpha, end_row)
    
    non_zeros_in_window = 0
    
    # 处理窗口内的所有行
    for row_idx in range(current_window_start_row, current_window_end_row):
        # 遍历该行的所有 neighbor
        for neighbor_idx in column_indices:
            # 访问缓存...
        
    # 计算该窗口的计算周期
    total_mac_ops = non_zeros_in_window * feature_len
    effective_parallelism = min(mac_array_width, beta)
    compute_cycles = np.ceil(total_mac_ops / effective_parallelism)
```

## 四种窗口形状

### 1. (8, 1) - "Tall & Narrow"
```
[Row i]
[Row i+1]
[Row i+2]
[Row i+3]
[Row i+4]
[Row i+5]
[Row i+6]
[Row i+7]

← 每次处理 8 行，宽度 1
→ 高度优先，适合列数很多的行
```

### 2. (4, 2) - "Medium"
```
[Row i    ] [Row i+1  ]
[Row i+2  ] [Row i+3  ]

← 每次处理 4 行，宽度 2
→ 平衡高度和宽度
```

### 3. (2, 4) - "Short & Wide"
```
[Row i  ] [Row i+1] [Row i+2] [Row i+3]

← 每次处理 2 行，宽度 4
→ 宽度优先，适合列数较少的行
```

### 4. (1, 8) - "Flat & Wide"
```
[Row i] [Row i+1] [Row i+2] ... [Row i+7]

← 每次处理 1 行，宽度 8
→ 最大宽度，适合很长很密集的行
```

## 自适应选择策略

### Profiling 阶段

```python:284-312:BSGCN_Metis_Order/simulator.py
# 对每种窗口形状进行 Profiling
for shape in window_shapes:
    hdn_clone = baseline_hdn_cache.clone()
    glc_clone = baseline_glc.clone()
    profiling_logger = StatsLogger()
    cycles = self._simulate_window_pass(
        matrix, profiling_band, shape, 
        profiling_logger,
        hdn_spm=hdn_clone, global_cache=glc_clone,
        record_ldn_access=False,  # 不统计
    )
    if cycles < min_cycles:
        min_cycles = cycles
        best_shape = shape  # ← 选择周期最短的窗口
```

### 执行阶段

```python:315-323:BSGCN_Metis_Order/simulator.py
# 使用最佳窗口形状处理整个大带
self._simulate_window_pass(
    matrix, band, best_shape, self.stats,
    hdn_spm=self.hdn_spm, global_cache=self.global_cache,
    record_ldn_access=True,  # ← 统计真实访问
)
```

## 遍历示例

假设一个大带有 **500 行**，选中的窗口形状是 **(8, 1)**：

```
起始: row 1000

Window 0: rows 1000-1007 (8 rows)
  ↓
Window 1: rows 1008-1015 (8 rows)
  ↓
Window 2: rows 1016-1023 (8 rows)
  ↓
...
Window 62: rows 1496-1500 (5 rows, 剩余)

总窗口数：63500 / 864 = 63 个窗口
```

## 与 Small Band 的对比

### Small Band（逐行遍历）

```python:181-197:BSGCN_Metis_Order/simulator.py
for row_idx in range(start, end):  # ← 逐行处理
    for nnz_ptr in range(row_start, row_end):
        neighbor_idx = indices[nnz_ptr]
        # 访问逻辑...
```

**特点**：
- 简单直接
- 每次处理一行
- 适合小规模数据

### Large Band（窗口式遍历）

```python:230-266:BSGCN_Metis_Order/simulator.py
for i in range(start_row, end_row, alpha):  # ← 窗口式跳跃
    window = range(i, min(i + alpha, end_row))
    # 收集窗口内所有 nonzeros
    # 批量计算周期
```

**特点**：
- 自适应选择最优形状
- 提高并行度利用
- 适合大规模稀疏矩阵

## 为什么使用窗口式遍历？

### 性能优化

1. **批量计算**
   - 收集整个窗口的 nonzeros
   - 统一计算 MAC 操作
   - 减少循环开销

2. **并行度管理**
   - `effective_parallelism = min(mac_array_width, beta)`
   - 窗口宽度决定并行度
   - 充分利用硬件资源

3. **自适应选择**
   - 稀疏矩阵形状各异
   - 不同稀疏模式适合不同窗口
   - Profiling 找出最优配置

## 实际运行示例

### Collab 数据集

```
大带：[0, 11736]，length: 11737 rows
选定窗口形状：(8, 1)
遍历方式：
  - 窗口 0: rows 0-7
  - 窗口 1: rows 8-15
  - ...
  - 窗口 1466: rows 11728-11736
```

### 窗口选择逻辑

对于不同的大带，系统会：
1. **Profiling**：在前 32 行测试所有窗口形状
2. **选择**：选择周期最短的形状
3. **执行**：用选定形状处理整个大带

## 可视化表示

```
一个大带的遍历过程：

行索引 → 0   8   16  24  32  ...
         ↓   ↓   ↓   ↓   ↓
窗口    [0-7][8-15][16-23][24-31] ...

对于 (8, 1) 窗口：
- alpha = 8: 每次处理 8 行
- beta = 1: 并行度为 1（实际上是指窗口内处理模式）

对于 (2, 4) 窗口：
- alpha = 2: 每次处理 2 行
- beta = 4: 可以在 4 个邻居上并行
```

## 总结

### 遍历形状特点

| 特性 | Small Band | Large Band |
|------|------------|------------|
| 遍历方式 | 逐行 | 窗口式（自适应） |
| 窗口形状 | N/A | (8,1), (4,2), (2,4), (1,8) |
| 选择策略 | 无 | Profiling 选择 |
| 并行度 | 固定 | 窗口宽度决定 |

### 关键理解

1. **大带不是逐行处理**，而是用窗口批量处理
2. **窗口形状自适应选择**，不同稀疏模式用不同形状
3. **GLC 访问分布在整个大带中**，每个窗口内的 LDN→LDN 访问都统计

因此，你的大带遍历是 **优化的窗口式遍历**，而不是简单的逐行访问。

